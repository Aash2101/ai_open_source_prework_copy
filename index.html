<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini MMORPG</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        class GameState {
            constructor() {
                this.playerId = null;
                this.players = new Map();
                this.avatars = new Map();
                this.viewport = { x: 0, y: 0 };
                this.clickMarker = null;  // Store click destination
                this.emotes = new Map();  // Store active emotes
                this.footsteps = new Map();  // Store footstep particles
                this.showHelp = true;     // Show help overlay by default
                this.particles = [];      // Store particle effects
                this.treasures = new Map(); // Store treasure chests
                this.points = 0;          // Player's score
                this.lastTreasureSpawn = 0; // Last treasure spawn time
                
                // Create treasure chest image
                this.treasureImage = new Image();
                this.treasureImage.src = 'data:image/svg+xml,' + encodeURIComponent(`
                    <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                        <rect x="4" y="12" width="24" height="16" fill="saddlebrown"/>
                        <rect x="6" y="14" width="20" height="12" fill="goldenrod"/>
                        <rect x="2" y="16" width="28" height="4" fill="darkgoldenrod"/>
                        <circle cx="16" cy="18" r="2" fill="gold"/>
                    </svg>
                `);
            }
            
            // Convert screen coordinates to world coordinates
            screenToWorld(screenX, screenY) {
                return {
                    x: screenX + this.viewport.x,
                    y: screenY + this.viewport.y
                };
            }
            
            // Convert world coordinates to screen coordinates
            worldToScreen(worldX, worldY) {
                return {
                    x: worldX - this.viewport.x,
                    y: worldY - this.viewport.y
                };
            }
        }

        class Avatar {
            constructor(avatarData) {
                this.frames = new Map();
                this.loadFrames(avatarData);
            }

            async loadFrames(avatarData) {
                for (const [direction, frames] of Object.entries(avatarData.frames)) {
                    this.frames.set(direction, []);
                    for (const frameData of frames) {
                        // Create an image from base64 data
                        const img = new Image();
                        img.src = frameData;
                        await new Promise(resolve => {
                            img.onload = resolve;
                        });
                        // Convert to ImageBitmap for efficient rendering
                        const bitmap = await createImageBitmap(img);
                        this.frames.get(direction).push(bitmap);
                    }
                }
            }

            draw(ctx, x, y, facing, frame, username) {
                const frames = this.frames.get(facing);
                if (!frames) return;
                
                const frameIdx = frame % frames.length;
                const sprite = frames[frameIdx];
                
                // Draw avatar
                if (facing === 'west') {
                    // Flip east frames horizontally for west-facing
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.drawImage(sprite, -x - sprite.width, y);
                    ctx.restore();
                } else {
                    ctx.drawImage(sprite, x, y);
                }

                // Draw username
                ctx.save();
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(username, x + sprite.width/2, y);
                ctx.fillText(username, x + sprite.width/2, y);
                ctx.restore();
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = new GameState();
                this.worldMap = new Image();
                this.worldMap.src = 'world.jpg';
                
                // Movement state
                this.pressedKeys = new Set();
                this.keyToDirection = {
                    'arrowup': 'up',
                    'arrowdown': 'down',
                    'arrowleft': 'left',
                    'arrowright': 'right',
                    'w': 'up',
                    's': 'down',
                    'a': 'left',
                    'd': 'right'
                };
                
                // Wait for map to load before connecting
                this.worldMap.onload = () => {
                    this.setupWebSocket();
                    this.setupKeyboardControls();
                    this.setupClickControls();
                    
                    // Create marker image
                    this.markerImage = new Image();
                    this.markerImage.src = 'data:image/svg+xml,' + encodeURIComponent(`
                        <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="16" cy="16" r="14" fill="none" stroke="white" stroke-width="2"/>
                            <circle cx="16" cy="16" r="2" fill="white"/>
                        </svg>
                    `);
                };

                // Set up resize handling
                this.resizeCanvas = this.resizeCanvas.bind(this);
                window.addEventListener('resize', this.resizeCanvas);
                this.resizeCanvas();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupWebSocket() {
                console.log('Setting up WebSocket connection...');
                this.ws = new WebSocket('wss://codepath-mmorg.onrender.com');
                
                this.ws.onopen = () => {
                    console.log('Connected to game server');
                    this.joinGame();
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleServerMessage(message);
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                this.ws.onclose = () => {
                    console.log('Disconnected from game server');
                };
            }

            joinGame() {
                const joinMessage = {
                    action: 'join_game',
                    username: 'Aashritha'
                };
                this.ws.send(JSON.stringify(joinMessage));
            }

            async             handleServerMessage(message) {
                console.log('Received server message:', message);
                if (message.success === false) {
                    console.error('Server error:', message.error);
                    return;
                }

                switch (message.action) {
                    case 'join_game':
                        console.log('Join game response:', message);
                        this.state.playerId = message.playerId;
                        console.log('Our player ID:', this.state.playerId);
                        
                        // Load avatars
                        for (const [name, avatarData] of Object.entries(message.avatars)) {
                            console.log('Loading avatar:', name);
                            const avatar = new Avatar(avatarData);
                            await avatar.loadFrames(avatarData);
                            this.state.avatars.set(name, avatar);
                        }

                        // Store player data
                        console.log('Initial player list:');
                        for (const [id, playerData] of Object.entries(message.players)) {
                            console.log(`Player ${playerData.username} (${id}):`, playerData);
                            this.state.players.set(id, playerData);
                        }

                        // Start game loop
                        this.startGameLoop();
                        break;

                    case 'player_joined':
                        console.log('New player joined:', message.player);
                        if (!this.state.avatars.has(message.avatar.name)) {
                            const avatar = new Avatar(message.avatar);
                            await avatar.loadFrames(message.avatar);
                            this.state.avatars.set(message.avatar.name, avatar);
                        }
                        this.state.players.set(message.player.id, message.player);
                        break;

                    case 'players_moved':
                        console.log('Players moved:', message.players);
                        for (const [id, playerData] of Object.entries(message.players)) {
                            if (this.state.players.has(id)) {
                                const player = this.state.players.get(id);
                                const oldX = player.x;
                                const oldY = player.y;
                                Object.assign(player, playerData);
                                console.log(`Player ${player.username} moved from (${oldX},${oldY}) to (${player.x},${player.y})`);
                            }
                        }
                        break;

                    case 'player_left':
                        const leavingPlayer = this.state.players.get(message.playerId);
                        console.log(`Player left: ${leavingPlayer ? leavingPlayer.username : message.playerId}`);
                        this.state.players.delete(message.playerId);
                        break;
                }
            }

            centerViewport() {
                const player = this.state.players.get(this.state.playerId);
                if (!player) return;

                // Calculate viewport position to center player
                this.state.viewport.x = player.x - this.canvas.width / 2;
                this.state.viewport.y = player.y - this.canvas.height / 2;

                // Clamp viewport to map bounds
                this.state.viewport.x = Math.max(0, Math.min(this.state.viewport.x, this.worldMap.width - this.canvas.width));
                this.state.viewport.y = Math.max(0, Math.min(this.state.viewport.y, this.worldMap.height - this.canvas.height));
            }

            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Center viewport on player
                this.centerViewport();

                // Draw visible portion of the map
                this.ctx.drawImage(
                    this.worldMap,
                    this.state.viewport.x, this.state.viewport.y,
                    this.canvas.width, this.canvas.height,
                    0, 0,
                    this.canvas.width, this.canvas.height
                );

                // Draw footsteps
                for (const [id, footsteps] of this.state.footsteps) {
                    const now = Date.now();
                    const updatedFootsteps = footsteps.filter(step => {
                        const age = now - step.timestamp;
                        if (age > 2000) return false;  // Remove after 2 seconds
                        
                        const screenPos = this.state.worldToScreen(step.x, step.y);
                        const alpha = 0.5 * (1 - age / 2000);
                        
                        this.ctx.save();
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        this.ctx.beginPath();
                        this.ctx.arc(screenPos.x + 16, screenPos.y + 24, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                        
                        return true;
                    });
                    
                    if (updatedFootsteps.length > 0) {
                        this.state.footsteps.set(id, updatedFootsteps);
                    } else {
                        this.state.footsteps.delete(id);
                    }
                }

                // Draw click marker
                if (this.state.clickMarker) {
                    const age = Date.now() - this.state.clickMarker.timestamp;
                    if (age < 1000) {  // Show for 1 second
                        const screenPos = this.state.worldToScreen(this.state.clickMarker.x, this.state.clickMarker.y);
                        const scale = 1 + (age / 1000);  // Grow effect
                        const alpha = 1 - (age / 1000);  // Fade out
                        
                        this.ctx.save();
                        this.ctx.globalAlpha = alpha;
                        this.ctx.translate(screenPos.x, screenPos.y);
                        this.ctx.scale(scale, scale);
                        this.ctx.drawImage(this.markerImage, -16, -16);
                        this.ctx.restore();
                    } else {
                        this.state.clickMarker = null;
                    }
                }

                // Draw treasures
                for (const [id, treasure] of this.state.treasures) {
                    if (!treasure.collected) {
                        const screenPos = this.state.worldToScreen(treasure.x, treasure.y);
                        
                        // Only draw if within viewport
                        if (screenPos.x >= -32 && screenPos.x <= this.canvas.width + 32 &&
                            screenPos.y >= -32 && screenPos.y <= this.canvas.height + 32) {
                            
                            // Add pulsing effect
                            treasure.pulsePhase = (treasure.pulsePhase + 0.05) % (Math.PI * 2);
                            const scale = 1 + Math.sin(treasure.pulsePhase) * 0.1;
                            
                            this.ctx.save();
                            this.ctx.translate(screenPos.x + 16, screenPos.y + 16);
                            this.ctx.scale(scale, scale);
                            this.ctx.drawImage(this.state.treasureImage, -16, -16);
                            
                            // Draw sparkle
                            if (Math.random() < 0.1) {  // 10% chance each frame
                                this.state.particles.push(this.createParticle(screenPos.x + 16, screenPos.y + 16, 'âœ¨'));
                            }
                            
                            this.ctx.restore();
                        }
                    }
                }

                // Draw all players
                for (const [id, player] of this.state.players) {
                    const avatar = this.state.avatars.get(player.avatar);
                    if (avatar) {
                        // Convert world coordinates to screen coordinates
                        const screenX = player.x - this.state.viewport.x;
                        const screenY = player.y - this.state.viewport.y;
                        
                        // Only draw if the player is within the viewport
                        if (screenX >= -100 && screenX <= this.canvas.width + 100 &&
                            screenY >= -100 && screenY <= this.canvas.height + 100) {
                            
                            // Create footsteps for moving players
                            if (player.isMoving && Math.random() < 0.1) {  // 10% chance each frame
                                this.createFootstep(id);
                            }
                            
                            // Highlight other players with a circle
                            if (id !== this.state.playerId) {
                                this.ctx.save();
                                this.ctx.beginPath();
                                this.ctx.arc(screenX + 16, screenY + 16, 20, 0, Math.PI * 2);
                                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                                this.ctx.lineWidth = 2;
                                this.ctx.stroke();
                                this.ctx.restore();
                            }
                            
                            avatar.draw(
                                this.ctx,
                                screenX,
                                screenY,
                                player.facing,
                                player.animationFrame,
                                player.username
                            );
                            
                            // Draw emotes
                            const emote = this.state.emotes.get(id);
                            if (emote) {
                                const emoteAge = Date.now() - emote.timestamp;
                                if (emoteAge < 2000) {  // Show for 2 seconds
                                    const yOffset = -30 - (emoteAge / 100);  // Float up
                                    const alpha = 1 - (emoteAge / 2000);  // Fade out
                                    
                                    this.ctx.save();
                                    this.ctx.font = '24px Arial';
                                    this.ctx.textAlign = 'center';
                                    this.ctx.textBaseline = 'bottom';
                                    this.ctx.globalAlpha = alpha;
                                    this.ctx.fillText(emote.emoji, screenX + 16, screenY + yOffset);
                                    this.ctx.restore();
                                } else {
                                    this.state.emotes.delete(id);
                                }
                            }
                        }
                    }
                }
                
                // Update and draw particles
                const now = Date.now();
                this.state.particles = this.state.particles.filter(particle => {
                    const age = now - particle.timestamp;
                    if (age > 1500) return false;  // Remove after 1.5 seconds
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1;  // Gravity
                    particle.alpha = 1 - (age / 1500);
                    
                    // Draw particle
                    this.ctx.save();
                    this.ctx.font = `${particle.size}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.globalAlpha = particle.alpha;
                    this.ctx.fillText(particle.emoji, particle.x, particle.y);
                    this.ctx.restore();
                    
                    return true;
                });

                // Draw help overlay
                if (this.state.showHelp) {
                    this.ctx.save();
                    
                    // Semi-transparent background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(10, 10, 300, 400);
                    
                    this.ctx.font = '20px Arial';
                    this.ctx.fillStyle = 'white';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    
                    let y = 30;
                    const lineHeight = 25;
                    
                    // Title
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.fillText('Controls Guide', 30, y);
                    y += lineHeight * 1.5;
                    
                    // Movement
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText('Movement:', 30, y);
                    y += lineHeight;
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText('â€¢ Arrow Keys or WASD to walk', 40, y);
                    y += lineHeight;
                    this.ctx.fillText('â€¢ Click anywhere to move there', 40, y);
                    y += lineHeight * 1.5;
                    
                    // Emotes
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText('Emotes:', 30, y);
                    y += lineHeight;
                    this.ctx.font = '16px Arial';
                    
                    // List all emotes
                    Object.entries(this.emoteMap).forEach(([key, emoji]) => {
                        this.ctx.fillText(`â€¢ Press ${key}: ${emoji}`, 40, y);
                        y += lineHeight;
                    });
                    
                    y += lineHeight * 1.5;
                    
                    // Treasure info
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText('Treasure Hunt:', 30, y);
                    y += lineHeight;
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText('â€¢ Find and collect treasure chests', 40, y);
                    y += lineHeight;
                    this.ctx.fillText('â€¢ Each chest gives 100 points', 40, y);
                    y += lineHeight;
                    this.ctx.fillText('â€¢ New chests spawn every 10 seconds', 40, y);
                    
                    y += lineHeight * 1.5;
                    this.ctx.fillText('Press H to toggle this help menu', 30, y);
                    
                    this.ctx.restore();
                } else {
                    // Show help reminder in center bottom
                    this.ctx.save();
                    this.ctx.font = '16px Arial';
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'bottom';
                    this.ctx.fillText('Press H for help', this.canvas.width / 2, this.canvas.height - 20);
                    
                    // Show score on right with background
                    this.ctx.save();
                    // Draw semi-transparent background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.roundRect(this.canvas.width - 200, 10, 180, 40, 10);
                    this.ctx.fill();
                    
                    // Draw score text
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillStyle = 'gold';
                    this.ctx.fillText(`Score: ${this.state.points}`, this.canvas.width - 30, 37);
                    this.ctx.restore();
                    this.ctx.restore();
                }

                // Debug: Show player information
                this.ctx.save();
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = 'white';
                let debugY = 20;
                this.ctx.fillText(`Players online: ${this.state.players.size}`, 10, debugY);
                debugY += 20;
                
                // Show info for each player
                for (const [id, player] of this.state.players) {
                    if (id !== this.state.playerId) {  // Only show other players
                        this.ctx.fillText(
                            `${player.username}: pos(${Math.round(player.x)},${Math.round(player.y)}) ` +
                            `facing:${player.facing} frame:${player.animationFrame} moving:${player.isMoving}`,
                            10, debugY
                        );
                        debugY += 20;
                    }
                }
                this.ctx.restore();
            }

            spawnTreasure() {
                const now = Date.now();
                if (now - this.state.lastTreasureSpawn < 10000) return; // Wait 10 seconds between spawns
                
                // Maximum 5 treasures at a time
                if (this.state.treasures.size >= 5) return;
                
                const id = 'treasure_' + now;
                const treasure = {
                    id: id,
                    x: Math.random() * 2048,  // Random position within map bounds
                    y: Math.random() * 2048,
                    timestamp: now,
                    collected: false,
                    pulsePhase: 0
                };
                
                this.state.treasures.set(id, treasure);
                this.state.lastTreasureSpawn = now;
                
                // Create sparkle effect at treasure location
                const screenPos = this.state.worldToScreen(treasure.x, treasure.y);
                for (let i = 0; i < 8; i++) {
                    this.state.particles.push(this.createParticle(screenPos.x, screenPos.y, 'âœ¨'));
                }
            }
            
            checkTreasureCollection() {
                const player = this.state.players.get(this.state.playerId);
                if (!player) return;
                
                for (const [id, treasure] of this.state.treasures) {
                    if (!treasure.collected) {
                        const dx = player.x - treasure.x;
                        const dy = player.y - treasure.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 40) {  // Collection radius
                            treasure.collected = true;
                            this.state.points += 100;  // Add points
                            
                            // Create collection effect
                            const screenPos = this.state.worldToScreen(treasure.x, treasure.y);
                            for (let i = 0; i < 12; i++) {
                                this.state.particles.push(this.createParticle(screenPos.x, screenPos.y, 'â­'));
                            }
                            
                            // Remove treasure after effect duration
                            setTimeout(() => {
                                this.state.treasures.delete(id);
                            }, 1000);
                        }
                    }
                }
            }

            startGameLoop() {
                const gameLoop = () => {
                    this.spawnTreasure();
                    this.checkTreasureCollection();
                    this.draw();
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }

            setupKeyboardControls() {
                console.log('Setting up keyboard controls');
                
                // Emote mappings
                this.emoteMap = {
                    '1': 'ðŸ‘‹',
                    '2': 'ðŸ˜Š',
                    '3': 'â¤ï¸',
                    '4': 'ðŸŽ‰',
                    '5': 'ðŸ‘',
                    '6': 'ðŸ¤”',
                    '7': 'ðŸ˜®',
                    '8': 'ðŸŒŸ',
                    '9': 'ðŸŽ®'
                };
                
                // Handle key press
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    console.log('Key pressed:', key);
                    
                    // Check if it's a movement key
                    if (this.keyToDirection[key] || this.keyToDirection[e.key]) {
                        console.log('Valid movement key detected:', key);
                        if (!this.pressedKeys.has(key)) {
                            this.pressedKeys.add(key);
                            this.sendMoveCommand(key);
                        }
                    }
                    
                    // Check if it's an emote key
                    if (this.emoteMap[e.key]) {
                        this.showEmote(this.state.playerId, this.emoteMap[e.key]);
                    }
                    
                    // Toggle help overlay with H key
                    if (key === 'h') {
                        this.state.showHelp = !this.state.showHelp;
                    }
                });

                // Handle key release
                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    this.pressedKeys.delete(key);
                    
                    // If no movement keys are pressed, send stop command
                    if (![...this.pressedKeys].some(k => this.keyToDirection[k])) {
                        this.sendStopCommand();
                    } else {
                        // If other keys are still pressed, move in the direction of the last pressed key
                        const lastKey = [...this.pressedKeys].filter(k => this.keyToDirection[k]).pop();
                        if (lastKey) {
                            this.sendMoveCommand(lastKey);
                        }
                    }
                });
            }

            sendMoveCommand(key) {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    console.log('WebSocket not ready:', this.ws ? this.ws.readyState : 'no websocket');
                    return;
                }

                const direction = this.keyToDirection[key];
                if (direction) {
                    const moveMessage = {
                        action: 'move',
                        direction: direction
                    };
                    console.log('Sending move command:', moveMessage);
                    this.ws.send(JSON.stringify(moveMessage));
                }
            }

            sendStopCommand() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                
                const stopMessage = {
                    action: 'stop'
                };
                this.ws.send(JSON.stringify(stopMessage));
            }

            setupClickControls() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const screenX = e.clientX - rect.left;
                    const screenY = e.clientY - rect.top;
                    const worldPos = this.state.screenToWorld(screenX, screenY);
                    
                    // Create click marker
                    this.state.clickMarker = {
                        x: worldPos.x,
                        y: worldPos.y,
                        timestamp: Date.now(),
                        alpha: 1.0
                    };
                    
                    // Send move command
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        const moveMessage = {
                            action: 'move',
                            x: Math.round(worldPos.x),
                            y: Math.round(worldPos.y)
                        };
                        this.ws.send(JSON.stringify(moveMessage));
                    }
                });
            }

            createParticle(x, y, emoji) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                const size = 16 + Math.random() * 8;
                
                return {
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2, // Initial upward velocity
                    size: size,
                    emoji: emoji,
                    alpha: 1,
                    timestamp: Date.now()
                };
            }

            showEmote(playerId, emoji) {
                const player = this.state.players.get(playerId);
                if (!player) return;
                
                this.state.emotes.set(playerId, {
                    emoji: emoji,
                    timestamp: Date.now(),
                    y: 0,  // offset from player
                    alpha: 1.0
                });
                
                // Create particles
                const screenPos = this.state.worldToScreen(player.x, player.y);
                for (let i = 0; i < 5; i++) {
                    this.state.particles.push(this.createParticle(screenPos.x + 16, screenPos.y - 20, emoji));
                }
            }

            createFootstep(playerId) {
                const player = this.state.players.get(playerId);
                if (!player || !player.isMoving) return;
                
                const footsteps = this.state.footsteps.get(playerId) || [];
                footsteps.push({
                    x: player.x,
                    y: player.y,
                    timestamp: Date.now(),
                    alpha: 0.5
                });
                
                // Limit number of footsteps
                if (footsteps.length > 10) {
                    footsteps.shift();
                }
                
                this.state.footsteps.set(playerId, footsteps);
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>
